# 爱彼迎Demo笔记
## 项目规范
- 项目规范: 
  - 命名规范:
    - 文件夹,文件名统一小写,多个单词由`-`连接
    - js变量小驼峰,常量全大写,组件大驼峰
  - css方面: 全局采用普通css,局部采用style-component
  - 整个项目全面使用Hooks
  - 全部函数式组件为了避免不必要渲染,统一用memo包裹
  - 组件之间的数据管理: useState,useReducer + redux管理
  - 组件内部代码编写顺序
    - state管理 (props/useState)
    - redux的hooks代码 (useSelector/useDispatch)
    - 其他hooks代码(自定义hooks)
    - 其他逻辑代码 (网络请求/事件监听/副作用)
    - 返回JSX代码
  - redux两种模式: 普通模式 / RTK模式都会使用
  - 网络请求axios的二次封装,所有模块请求统一放到一个文件中单独管理
  - 项目使用AntDesign(国内) Material UI(国外)
    - 爱彼迎设计风格偏向于Material UI
    - 大部分组件还需要自己编写,封装,实现

## 项目构建
- ==**很多东西可以照着Vue宏源旅途的笔记配置**==
- 1.vite创建react项目(仅js) --- airbnb
  > ==**由于react官方已经弃用了create-react-app,推荐vite等脚手架构建react项目,所以项目转向vite构建**==
- 2.项目标题和图标(/public),在index.html配置
- 3.引入jsconfig.json文件,更好地提示
- 4.创建的目录结构如下: 
  - pubilc: 动态可修改图片 (仅能简单理解)
  - src
    - assets: 静态不可修改图片
    - base-ui: 基础ui,在多个项目中使用
    - components: 公共多复用的组件
    - hooks
    - router
    - service: 网络请求相关
    - store
    - utils: 工具函数
    - views: 页面视图
- 5.配置别名: 
  - 下载`npm i @vitejs/plugin-vue`, 然后引入 path 并配置
  ```js
    // 引入path
    import path from 'path'

    // vite.config.js内部分代码
    resolve: {
      alias: {
        '@': path.resolve(__dirname, 'src')
      }
    }
  ```
  > @: 代表绝对路径下的 src 路径,以后配置 src 下的文件可以直接@代替,例如`@/componets/tabbae/tabbar.vue`
- 进一步配置更多的别名,比如
  ```js
    // alias原理: 别名 + 绝对路径
    // 绝对路径由path负责,__dirname会获取当前文件夹下的绝对路径,即/airbnb,再使用resolve进行路径拼接
    const resolve = pathName => path.resolve(__dirname, pathName)

    export default defineConfig({
      plugins: [react()],
      resolve: {
        alias: {
          '@': resolve('src'),
          'components': resolve('src/components'),
          'utils': resolve('src/utils')
        }
      }
    })
  ```
- 6.使用less和全局重置css样式 (==css代码复制宏远旅途==)
  - 直接下载 `npm i less`,然后可以直接使用,在文件引入css/less文件即可
  - 通用的重置css库: `npm i normalize.css` 
  - 自己写的重置样式: `/assets/css/reset.less` 
    > 为了方便,所有css样式统一引入index.css,然后由main.jsx引入index.css实现样式转变
  - ==main.jsx中不可以省略index.css,写完整==
    ```js
      import { StrictMode } from 'react'
      import { createRoot } from 'react-dom/client'
      import App from '@/App'
      import '@/assets/css/index.css'

      createRoot(document.getElementById('root')).render(
        <StrictMode>
          <App />
        </StrictMode>,
      )
    ```
  - 额外的,配置less主题颜色 `/assets/variable.less`
    ```css
      @textColor: #484848;
      @textColorSecondary: #222;
    ```
  - ==**vite默认支持CSS Modules, 任何以 .module.css 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象**==

## 路由配置
- vite中配置react路由和原本没有啥区别
- react-router现在已经推出v7版本,为最新版,优化比较多,对应的更新日志说明(从v6更新)和掘金上react-router v7使用说明 两篇文章均已收藏
- ==本质上v6->v7的变化不大,所以本项目使用v6版本==
- 下载: `npm i react-router-dom@6`,
- 1.创建三个页面 home/detail/entire
- 2.配置router/index 配置各种路由(懒加载+重定向+NotFound)
  ```js
    import React from "react";
    // 重定向
    import { Navigate } from "react-router-dom";

    // 懒加载,异步加载,需要在main.jsx中额外配置Suspense
    const Home = React.lazy(() => import('@/views/home'))
    const Detail = React.lazy(() => import('@/views/detail'))
    const Entire = React.lazy(() => import('@/views/entire'))
    const NotFound = React.lazy(() => import('@/views/notfound'))

    const routes = [
      {
        path: '/',
        element: <Navigate to='/home' />
      },
      {
        path: '/home',
        element: <Home />
      },
      {
        path: '/detail',
        element: <Detail />
      },
      {
        path: '/entire',
        element: <Entire />
      },
      {
        path: '*',
        element: <NotFound />
      }
    ]

    export default routes
  ```
- 3.在main.jsx配置Hash路由,另外路由懒加载需要在main.jsx配置Suspense处理异步的加载问题
  ```js
    // 路由模式 Hash
    import { HashRouter } from 'react-router-dom'
    // 组件的异步加载方案
    import { Suspense } from 'react'

    <StrictMode>
      {/* 可以选择字符串或组件,在加载过程中显示 */}
      <Suspense fallback='loading' >  
        {/* hash模式路由 */}
        <HashRouter>
          <App />
        </HashRouter>
      </Suspense>
    </StrictMode>
  ```
- 4.App.jsx使用路由
  ```js
    import React, { memo } from 'react'
    import routes from '@/router'
    import { useRoutes } from 'react-router-dom'

    const App = memo(() => {
      return (
        <div className='app'>
          <div className='header'>header</div>
          <div className='page'>
            {useRoutes(routes)}
          </div>
          <div className='footer'>footer</div>
        </div>
      )
    })

    export default App
  ```
  > ==useRoutes约等于vue的router-view==

## redux状态管理
- vite中配置redux和原本没有啥区别
- ==优先使用redux/toolkit,可以穿插使用redux原生写法,不过toolkit未来是主流,它是语法糖,极大简化了redux的代码书写,为了练习两种写法都会用到==
- 下载: `npm i @reduxjs/toolkit react-redux redux`, react-redux负责连接redux和react
- 1.==配置reducer, 在/modules内,使用RTK和原版两种方式配置==
  - 1.1 首页home因为数据过多,所以使用RTK写法
    ```js
      // /modules/home.js
      import { createSlice } from "@reduxjs/toolkit";

      const homeSlice = createSlice({
        name: 'home',
        initialState: {
          product: []
        },
        reducers: {

        }
      })

      export default homeSlice.reducer
    ```
  - 1.2 entire页面使用原生配置,创建文件夹 + 4个文件 (==出于练习目的,以后推荐统一RTK==)
    ```js
    // reducer.js
    const initialState = {
      currentNumber: 0
    }

    function reducer(state = initialState, action) {
      switch (action.type) {
        // case ...
        default:
          return state
      }
    }

    export default reducer
    ```
    ```js
      // index.js
      import reducer from './reducer'
      export default reducer
    ```
- ==2.store/index配置(RTK)==
  ```js
    import { configureStore } from '@reduxjs/toolkit'
    import homeReducer from './modules/home' // RTK(redux/toolkit)
    import entireReducer from './modules/entire' // 普通redux

    // 支持所有的reducer函数引入(RTK/普通模式)
    const store = configureStore({
      reducer: {
        home: homeReducer,
        entire: entireReducer
      }
    })

    export default store
  ```
  > ==// 支持所有的reducer函数引入(RTK/普通模式)==
- 3.main.jsx引入store
  ```js
    // store共享
    import { Provider } from 'react-redux'
    import store from "@/store" // 引入store
    
    createRoot(document.getElementById('root')).render(
      <Suspense fallback='loading' >
        {/* 公开引入的store */}
        <Provider store={store}>
          <HashRouter>
            <App />
          </HashRouter>
        </Provider>
      </Suspense>
    )
  ```

## axios封装
- 之前封装过,在网络请求相关的笔记中,下载: `npm i axios`
- service文件夹结构略,axios封装代码(==简易版,和网络请求笔记中一样,略==)
- 配置的基础测试路径为: `http://codercba.com:1888/airbnb/api` (==接口文档已配置==)
- 测试网络请求时可以关闭严格模式,这样就不会连续请求2次了
- home页面的测试
  ```js
    const home = memo(() => {
      // 简单使用,后面的网络请求会融入到redux中
      // 定义状态 
      const [highscore, setHightScore] = useState({})

      // 网络请求代码,类似Mount
      useEffect(() => {
        hyRequest.get({ url: '/home/highscore' }).then(res => {
          // console.log(res)
          setHightScore(res)
        })
      }, [])

      return (
        <div>home
          {/* 简单测试 */}
          <h2>{highscore.title}</h2>
          <h4>{highscore.subtitle}</h4>
          <ul>
            {/* 异步初始没有数据,使用可选链 */}
            {
              highscore?.list?.map(item => {
                return <li key={item.id}>{item.name}</li>
              })
            }
          </ul>
        </div>
      )
    })
  ```


