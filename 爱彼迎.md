# 爱彼迎Demo笔记
## 项目准备(*)
### 项目规范
- 项目规范: 
  - 命名规范:
    - 文件夹,文件名统一小写,多个单词由`-`连接
    - js变量小驼峰,常量全大写,组件大驼峰
  - css方面: 全局采用普通css,局部采用style-component
  - 整个项目全面使用Hooks
  - 全部函数式组件为了避免不必要渲染,统一用memo包裹
  - 组件之间的数据管理: useState,useReducer + redux管理
  - 组件内部代码编写顺序
    - state管理 (props/useState)
    - redux的hooks代码 (useSelector/useDispatch)
    - 其他hooks代码(自定义hooks)
    - 其他逻辑代码 (网络请求/事件监听/副作用)
    - 返回JSX代码
  - redux两种模式: 普通模式 / RTK模式都会使用
  - 网络请求axios的二次封装,所有模块请求统一放到一个文件中单独管理
  - 项目使用AntDesign(国内) Material UI(国外)
    - 爱彼迎设计风格偏向于Material UI
    - 大部分组件还需要自己编写,封装,实现

### 项目构建
- ==**很多东西可以照着Vue宏源旅途的笔记配置**==
- 1.vite创建react项目(仅js) --- airbnb
  > ==**由于react官方已经弃用了create-react-app,推荐vite等脚手架构建react项目,所以项目转向vite构建**==
- 2.项目标题和图标(/public),在index.html配置
- 3.引入jsconfig.json文件,更好地提示
- 4.创建的目录结构如下: 
  - pubilc: 动态可修改图片 (仅能简单理解)
  - src
    - assets: 静态不可修改图片
    - base-ui: 基础ui,在多个项目中使用
    - components: 公共多复用的组件
    - hooks
    - router
    - service: 网络请求相关
    - store
    - utils: 工具函数
    - views: 页面视图
- 5.配置别名: 
  - 下载`npm i @vitejs/plugin-vue`, 然后引入 path 并配置
  ```js
    // 引入path
    import path from 'path'

    // vite.config.js内部分代码
    resolve: {
      alias: {
        '@': path.resolve(__dirname, 'src')
      }
    }
  ```
  > @: 代表绝对路径下的 src 路径,以后配置 src 下的文件可以直接@代替,例如`@/componets/tabbae/tabbar.vue`
- 进一步配置更多的别名,比如
  ```js
    // alias原理: 别名 + 绝对路径
    // 绝对路径由path负责,__dirname会获取当前文件夹下的绝对路径,即/airbnb,再使用resolve进行路径拼接
    const resolve = pathName => path.resolve(__dirname, pathName)

    export default defineConfig({
      plugins: [react()],
      resolve: {
        alias: {
          '@': resolve('src'),
          'components': resolve('src/components'),
          'utils': resolve('src/utils')
        }
      }
    })
  ```
- 6.使用less和全局重置css样式 (==css代码复制宏远旅途==)
  - 直接下载 `npm i less`,然后可以直接使用,在文件引入css/less文件即可
  - 通用的重置css库: `npm i normalize.css` 
  - 自己写的重置样式: `/assets/css/reset.less` 
    > 为了方便,所有css样式统一引入index.css,然后由main.jsx引入index.css实现样式转变
  - ==main.jsx中不可以省略index.css,写完整==
    ```js
      import { StrictMode } from 'react'
      import { createRoot } from 'react-dom/client'
      import App from '@/App'
      import '@/assets/css/index.css'

      createRoot(document.getElementById('root')).render(
        <StrictMode>
          <App />
        </StrictMode>,
      )
    ```
  - 额外的,配置less主题颜色 `/assets/variable.less`
    ```css
      @textColor: #484848;
      @textColorSecondary: #222;
    ```
  - ==vite默认支持CSS Modules==, 任何以 .module.css 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象, **但是项目中以'css in js'方案,也就是styled-components为主,所以需要下载`npm i styled-components`**

### 路由配置
- vite中配置react路由和原本没有啥区别
- react-router现在已经推出v7版本,为最新版,优化比较多,对应的更新日志说明(从v6更新)和掘金上react-router v7使用说明 两篇文章均已收藏
- ==本质上v6->v7的变化不大,所以本项目使用v6版本==
- 下载: `npm i react-router-dom@6`,
- 1.创建三个页面 home/detail/entire
- 2.配置router/index 配置各种路由(懒加载+重定向+NotFound)
  ```js
    import React from "react";
    // 重定向
    import { Navigate } from "react-router-dom";

    // 懒加载,异步加载,需要在main.jsx中额外配置Suspense
    const Home = React.lazy(() => import('@/views/home'))
    const Detail = React.lazy(() => import('@/views/detail'))
    const Entire = React.lazy(() => import('@/views/entire'))
    const NotFound = React.lazy(() => import('@/views/notfound'))

    const routes = [
      {
        path: '/',
        element: <Navigate to='/home' />
      },
      {
        path: '/home',
        element: <Home />
      },
      {
        path: '/detail',
        element: <Detail />
      },
      {
        path: '/entire',
        element: <Entire />
      },
      {
        path: '*',
        element: <NotFound />
      }
    ]

    export default routes
  ```
- 3.在main.jsx配置Hash路由,另外路由懒加载需要在main.jsx配置Suspense处理异步的加载问题
  ```js
    // 路由模式 Hash
    import { HashRouter } from 'react-router-dom'
    // 组件的异步加载方案
    import { Suspense } from 'react'

    <StrictMode>
      {/* 可以选择字符串或组件,在加载过程中显示 */}
      <Suspense fallback='loading' >  
        {/* hash模式路由 */}
        <HashRouter>
          <App />
        </HashRouter>
      </Suspense>
    </StrictMode>
  ```
- 4.App.jsx使用路由
  ```js
    import React, { memo } from 'react'
    import routes from '@/router'
    import { useRoutes } from 'react-router-dom'

    const App = memo(() => {
      return (
        <div className='app'>
          <div className='header'>header</div>
          <div className='page'>
            {useRoutes(routes)}
          </div>
          <div className='footer'>footer</div>
        </div>
      )
    })

    export default App
  ```
  > ==useRoutes约等于vue的router-view==

### redux状态管理
- vite中配置redux和原本没有啥区别
- ==优先使用redux/toolkit,可以穿插使用redux原生写法,不过toolkit未来是主流,它是语法糖,极大简化了redux的代码书写,为了练习两种写法都会用到==
- 下载: `npm i @reduxjs/toolkit react-redux redux`, react-redux负责连接redux和react
- 1.==配置reducer, 在/modules内,使用RTK和原版两种方式配置==
  - 1.1 首页home因为数据过多,所以使用RTK写法
    ```js
      // /modules/home.js
      import { createSlice } from "@reduxjs/toolkit";

      const homeSlice = createSlice({
        name: 'home',
        initialState: {
          product: []
        },
        reducers: {

        }
      })

      export default homeSlice.reducer
    ```
  - 1.2 entire页面使用原生配置,创建文件夹 + 4个文件 (==出于练习目的,以后推荐统一RTK==)
    ```js
    // reducer.js
    const initialState = {
      currentNumber: 0
    }

    function reducer(state = initialState, action) {
      switch (action.type) {
        // case ...
        default:
          return state
      }
    }

    export default reducer
    ```
    ```js
      // index.js
      import reducer from './reducer'
      export default reducer
    ```
- ==2.store/index配置(RTK)==
  ```js
    import { configureStore } from '@reduxjs/toolkit'
    import homeReducer from './modules/home' // RTK(redux/toolkit)
    import entireReducer from './modules/entire' // 普通redux

    // 支持所有的reducer函数引入(RTK/普通模式)
    const store = configureStore({
      reducer: {
        home: homeReducer,
        entire: entireReducer
      }
    })

    export default store
  ```
  > ==// 支持所有的reducer函数引入(RTK/普通模式)==
- 3.main.jsx引入store
  ```js
    // store共享
    import { Provider } from 'react-redux'
    import store from "@/store" // 引入store
    
    createRoot(document.getElementById('root')).render(
      <Suspense fallback='loading' >
        {/* 公开引入的store */}
        <Provider store={store}>
          <HashRouter>
            <App />
          </HashRouter>
        </Provider>
      </Suspense>
    )
  ```

### axios封装
- 之前封装过,在网络请求相关的笔记中,下载: `npm i axios`
- service文件夹结构略,axios封装代码(==简易版,和网络请求笔记中一样,略==)
- 配置的基础测试路径为: `http://codercba.com:1888/airbnb/api` (==接口文档已配置==)
- 测试网络请求时可以关闭严格模式,这样就不会连续请求2次了
- home页面的测试
  ```js
    const home = memo(() => {
      // 简单使用,后面的网络请求会融入到redux中
      // 定义状态 
      const [highscore, setHightScore] = useState({})

      // 网络请求代码,类似Mount
      useEffect(() => {
        hyRequest.get({ url: '/home/highscore' }).then(res => {
          // console.log(res)
          setHightScore(res)
        })
      }, [])

      return (
        <div>home
          {/* 简单测试 */}
          <h2>{highscore.title}</h2>
          <h4>{highscore.subtitle}</h4>
          <ul>
            {/* 异步初始没有数据,使用可选链 */}
            {
              highscore?.list?.map(item => {
                return <li key={item.id}>{item.name}</li>
              })
            }
          </ul>
        </div>
      )
    })
  ```
## Header搭建
- ==针对Header的搭建==,爱彼迎网站的header有3种样式,并且在下滑时,有的顶部栏样式会变化,有的会fixed,有的不会fixed,区别比较大,不好做;
- ==方案一: 写一个组件,对应改变状态 方案二: 搞3个实例header,一个页面一个header,更简单==
- ==选择方案一==: App.jsx中的header部分封装为组件 -> components (同理footer也顺带封装)
  - ==header分为左中右三个部分,布局居中的思路==,左右两侧宽度不同,如果左右设定好宽度,中间flex: 1,在最后中间部分align-center肯定是不居中的; 所以应当左右两侧flex: 1(平分center剩余的宽度),中间设定宽度,这样一定居中,在对应的文件style.js配置样式
### logo与主题(*)
- ==**针对左侧LeftHeader**==
- ==左侧部分的logo部分: svg的深入学习后面学习图形处理再学习(大屏可视化Canvans等)==
  - svg不同于png jpg等图片可以直接下载,它是形如`<svg><path></path></svg>`格式的元素,是js渲染出的图案,我们复制网站的svg元素,存入`assets/svg`中,以reactElement的格式导出(.jsx),然后在对应的文件引入即可,其中svg中的style属性不支持字符串(这是jsx),需要`style={{css属性书写}}`,内置对象,需要额外的转化函数,coderwhy老师对于这种转化麻烦的函数可以直接从standoverflow上面找,style转obj的函数(都是正则表达式),已存入svg/utils文件中,在对应svg文件中直接引入使用,对应的字符串css样式传入函数即可
- ==定制主题theme,另外Ant Design上面也有一些预制主题==
  - styled-components有一个ThemeProvider方法,和共享store一样,可以共享主题
    ```js
      // 最外层index.js
      // styled-components 主题共享
      import { ThemeProvider } from 'styled-components'
      // 引入css主题
      import theme from '@/assets/theme' 

      {/* 公开store */}
      <Provider store={store}>
        {/* 公开css主题 theme */}
        <ThemeProvider theme={theme}>
          <HashRouter>
            <App />
          </HashRouter>
        </ThemeProvider>
      </Provider>
    ```
  - 配置主题theme `assets/theme/index.js`
    ```js
      const theme = {
        color: {
          primaryColor: "#ff385c",
          secondaryColor: "#00848A"
        }
      }

      export default theme
    ```
    > 可以写多个,比如有的网站有白天和黑夜2个模式,这里也可以设置多个不同的主题
  - ==使用主题,给Airbnb的logo和字体添加主题颜色==
  - 同时给logo优化: 加点击cursor: pointer属性和间距等css样式
    ```js
      import styled from 'styled-components'

      export const LeftWrapper = styled.div`
          flex: 1;
          color: ${props => props.theme.color.primaryColor};
          .left{
            display: flex;
            align-items: center;
            .logo{
              padding-left: 15px;
              cursor: pointer;
            }
          .text{
            cursor: pointer;
            padding-left: 8px;
            color: ${props => props.theme.color.primaryColor};
          }
        } 
    ```
    > ==模板字符串中使用变量`${}`,传入的theme在props参数内,这是函数调用的一种特殊方式,所以可以直接在`${}`内直接获取到props,进而找到公开的主题==
### RightHeader
- 主要学习css的样式
- 简单的2个svg图片和按钮样式(由div模仿),补充了一些主题色,配置了一些css样式,代码略,详见对应header-right/style.js
- ==less样式混入,把css样式当作字符串抽取==
  ```js
    // 主题 /assets/theme/index.js
    const theme = {
      // ...
      mixin:{
        /* 阴影+动画过渡 */
        boxShadow: ` 
          transition: box-shadow 200ms ease;
          &:hover{
            box-shadow: 0 2px 4px rgba(0,0,0,.18); 
          }
        `
      }
    }
    export default theme
  ```
- 在使用时直接引入即可
  ```js
    .profile{
      // ....
      // 引入阴影部分的css代码
      ${props => props.theme.mixin.boxShadow}
    }
  ```
### CenterHeader(略)
- 简单配置了样式和页面结构,简单看下代码即可,搜索框+svg(搜索图标),略
### Profile动态面板(*)
- 点击RightHeader的Menu图标,也是个人中心区域(Profile),然后在下方显示动态面板,同时没有蒙版,也就是在动态面板显示的同时,仍然可以操纵后面页面的其他元素,同时点击出动态面板外任意地方都可以关闭动态面板
- ==练习动态面板+蒙版的变式,值得回忆==
- 监听对象改为window,只要点击到window,就隐藏动态面板,不加蒙版
- 动态面板panel和其css样式省略,下面是js逻辑
  ```js
  // HeaderRight.jsx
  const HeaderRight = memo(() => {
      /** 定义组件内部状态 */
      // 控制Profile动态面板的显示和隐藏
      const [showPanel, setShowPanel] = useState(false)

      /** 副作用代码 */
      useEffect(() => {
        function windowHandleClick() {
          setShowPanel(false)
        }
        // 添加监听,第二个参数是捕获阶段监听,防止点击profile冒泡到window,误触发了隐藏panel的事件
        window.addEventListener('click', windowHandleClick, true)
        // 取消监听
        return () => {
          window.removeEventListener('click', windowHandleClick)
        }
      }, [])

      /** 事件处理函数 */
      function profileClickHandler() {
        setShowPanel(true)
      }

      return (
        <RightWrapper>
          <div className='profile' onClick={profileClickHandler}>
            <IconMenu />
            {
              showPanel && (
                <div className='panel'>
                  // .....
                </div>
              )
            }
          </div>
        </RightWrapper>
      )
    })
  ```
## 首页home
### 顶部轮播图
- 用第三方库做轮播图,Ant Design
- vite动态引入本地的图片不能直接用相对路径或字符串,如下显示,这是webpack底层打包的问题
  ```css
    background: url('@/assets/...');
    <img src='../../assets/...' />
  ```
- 无论是img还是url(),都可以引入图片作为变量使用
  ```js
    import styled from "styled-components";
    import coverImg from '@/assets/img/home/cover_01.jpeg' // 本地静态资源引入

    export const BannerWrapper = styled.div`
      height: 529px;
      background: url(${coverImg}) center/cover;
    `
  ```
  ```js
    <img src="{coverImg}" alt="" />
  ```
### 高性价比房源(*)
- ==做内容区content的房源菜单部分==, 高性价比房源api: http://codercba.com:1888/airbnb/api/home/goodprice
- ==服务器请求的数据放在redux中由store管理,而不是在单独的组件直接axios,在组件内发起网络请求,而执行请求的部分在redux中==
- ==1.创建对应的store/home.js(RTK)==
- ==axios网络请求, 处理异步数据, 保存state==
  ```js
    import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
    import { getHomeGoodPriceData } from "@/service";

    /** 异步请求数据的函数,记得导出 */
    export const fetchGoodPriceAction = createAsyncThunk('fetch/goodPriceData', async (payload) => {
      const res = await getHomeGoodPriceData()
      return res // .data已经在封装过了
    })

    const homeSlice = createSlice({
      name: 'home',
      initialState: {
        goodPriceInfo: {}
      },
      /** 保存异步数据->state */
      extraReducers: (builder) => {
        /** 处理成功信息 */
        builder.addCase(fetchGoodPriceAction.fulfilled, (state, {payload}) => {
          // console.log('extraReducer',payload)
          state.goodPriceInfo = payload
        })
        
        /** 处理错误信息 */
        builder.addCase(fetchGoodPriceAction.rejected, (state,action) => {
          if(state.err.message){
            console.log(action.error)
          } 
        })
      }
    })

    export default homeSlice.reducer
  ```
- 2.请求数据函数封装进service/modules/home
  ```js
    import hyRequest from "@/service";

    export function getHomeGoodPriceData(){
      return hyRequest.get({
        url: '/home/goodprice'
      })
    }
  ```
- 2.1记得导出home内部的函数
  ```js
    // service/index.js
    // 导出home内所有函数
    export * from './modules/home'
  ```
- 3.在views/home/index.jsx,派送请求并使用store
  ```js
      /** 从redux中获取数据 */
      const {goodPriceInfo} = useSelector((state) => ({
        goodPriceInfo: state.home.goodPriceInfo
      }), shallowEqual)

      /** 派发事件: 发送网络请求,不传参数 */
      const dispatch = useDispatch()
      useEffect(() => {
        dispatch(fetchGoodPriceAction())
      },[])

      return (
        <HomeWrapper>
          {/* 轮播图 */}
          <HomeBanner/>
          <div className='content'>
            <h2>{goodPriceInfo.title}</h2>
            <ul>
              {
                goodPriceInfo?.list?.map(item => {
                  return <li key={item.id}>{item.name}</li>
                })
              }
            </ul>
          </div>
        </HomeWrapper>
      )
  ```
### app-footer搭建(略)
- 使用codewhy老师的数据和样式,直接复制过来的,可以看看代码怎么写的,就是页面底部的内容,components/app-footer
- 数据在assets/data/footer.json中
### section-header
- 公用组件: 头部信息栏 section-header
- 创建命令: `rmcp`,创建可以接受props参数类型的组件,限制接受数据的类型
- 需要下载: `npm i prop-types` 
- 代码很简单,接受主标题和副标题,副标题可能没有,所以选择性显示
  ```js
    const SectionHeader = memo((props) => {
      // const {title,subtitle = '默认子标题'} = props
      const {title,subtitle} = props

      return (
        <HeaderWrapper>
          <h2 className='title'>{title}</h2>
          {subtitle && <div className='subtitle'>{subtitle}</div>}
        </HeaderWrapper>
      )
    })
  ```
### room-item(*)
- 配置内容区的每个房源Item数据,只展示前8个,在map遍历前用slice截取一下即可
- 每个room-item展示如下图
  [![pExnbLD.png](https://s21.ax1x.com/2025/05/20/pExnbLD.png)](https://imgse.com/i/pExnbLD)
- ==1.封装公共组件room-item, 给每个li的传入数据(itemData)==
  ```js
    // home/index.jsx
    <ul className='room-list'>
      {
        goodPriceInfo?.list?.slice(0,8).map(item => {
          return <RoomItem itemData={item} key={item.id} />
        })
      }
    </ul>
  ```
- ==2.组件room-item(类比li)与ul的css样式==
  - 后期组件有复用性,组件的宽度是变化的,有时候一行4个,有时候一行5个,对应width(25%/20%),所以不建议写死width是多少px
  - ==每个room-item都是左右间距8px,但是首尾没有间距,coderwhy老师提供了一个非常好的方法(简便)==
  - room-item(li)的css样式,先平等4分,然后怪异盒内pad 8px
    ```css
      width: 25%;
      padding: 8px;
      box-sizing: border-box;
    ```
  - ul的样式,保证flex布局和换行,把首位room-item多撑出来的pad,向内部的左右margin 8px
    ```css
      .room-list{
        margin: 0 -8px;
        display: flex;
        flex-wrap: wrap;
      } 
    ```
- ==3.解决图片比例不同的问题: 爱彼迎服务器给前端的图片的比例不同,导致同样设置width 100%,对应的图片高度不同==
    - cover提供占位,高为宽的2/3
    - img绝对定位把cover提供的占位占满
    ```css
       /* cover & img 保证图片大小一致
          html结构上,img是cover的子,子绝父相 */
      .cover {
        position: relative;
        box-sizing: border-box;
        padding: 66.66% 8px 0; /* 上 左右 下 */
        border-radius: 3px;
        overflow: hidden;

        img {
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
        }
      }
    ```
- ==没有图片img下,cover的占位示意图如下==
  [![pExnHsO.png](https://s21.ax1x.com/2025/05/20/pExnHsO.png)](https://imgse.com/i/pExnHsO)
  > 最后这个区域会被img覆盖,这样所有的图片大小就一致了
- ==4.额外的,服务器还传递额外的字体颜色数据,如何向css in js中传递变量,前面也学习了,如下==
    ```html
    <!-- room-item: 传递服务器变量数据, 这里记得加$(文档要求的)  -->
    <ItemWrapper $verifyColor={itemData?.verify_info?.text_color || '#39576a'}>
      <!-- ..... -->
    </ItemWrapper>
    ```
- 内部css in js通过props获取使用即可
  ```css
     .desc {
        margin: 10px 0 5px;
        font-size: 12px;
        font-weight: 700;
        /* 接受服务器传递的动态文字颜色 */
        color: ${props => props.verifyColor};
      }
  ```
- 5.次要的内容
  - room-item内部小布局 div-inner, 简单的html和css布局, 略
  - 评分的星星 -> ui库 (后面再用,先略过)  
  - 配置了assets/css/common.css的一点样式,颜色和字体

### React-UI库(*)
- Ant和MUI两个组件库(Ant Design/Material),更加适用于后台管理系统
- ==1.MUI组件库安装==
  - ==**支持emotion或styled-components两种方式,但是对于SSR渲染强烈建议用emotion**==
  - **emotion**: `npm install @mui/material @emotion/react @emotion/styled`
  - **styled-components**: `npm install @mui/material @mui/styled-engine-sc styled-components`
- ==MUI默认支持emotion,所以使用styled-components需要额外的配置==
- 在vite.config.js中添加别名
  ```js
     module.exports = {
        //...
      +  resolve: {
      +    alias: {
      +      '@mui/styled-engine': '@mui/styled-engine-sc'
      +    },
      +  },
      }
  ```
  > 接下来可以使用MUI了
- ==**额外的,官方提供的兼容包@mui/styled-engine-sc可能因为和@mui/material版本不兼容问题导致失效,所以可以下载@mui/system代替**==
- 删除vite.config.js中的别名和卸载掉`@mui/styled-engine-sc`包
- 下载: `npm i npm install @mui/system`
- 完成上述一般可以运行了,如果还不行可以把emotion相关文档也下载下来,反正推荐
- ==2.集成Ant Design== 
- 下载`npm i antd`,直接使用即可,额外的,现在antv5版本需要安装兼容包兼容r19,在v6版本将会适配
- 兼容包下载: `npm install @ant-design/v5-patch-for-react-19 --save`
- 项目入口main.js引入 `import '@ant-design/v5-patch-for-react-19';`
- ==目前下来,可以根据要用的组件库单独引入使用即可,复制文档的引入==

### MUI_Rating
- 评分Rating组件(MUI组件库)
- 在room-item中,学习了Rating组件的一些属性,配置了点css样式(略)
  ```js
    import Rating from '@mui/material/Rating';

    {/* sx: 设置新的样式覆盖旧的样式 
        precision: 精准度,精确到0.1
        ??: 更加严谨,只有前面数据为Null或Undefined时才会执行后面的
        不使用'||'为了防止出现 0 || 4.5 => 4.5的情况,对0也默认执行后面
    */}
    <Rating
      value={itemData.star_rating ?? 4.5}
      precision={0.1}
      size="small"
      sx={{ fontSize: '12px', color: '#00848A' }}
      readOnly
    />
  ```
### section-rooms(略)
- 重构room-list封装进通用组件`section-rooms`,==注意获取数据的变化==
- 把之前的ul部分替代为组件,剩余不变
### 高评分房源
- 和高性价比的房源布局差不多, api: http://codercba.com:1888/airbnb/api/home/highscore
- 步骤: 
  - 1.封装对应的网络请求(老位置service),请求高分房源,代码略
  - ==2.多个异步数据请求RTK store/home.jsx==
    ```js
      /** 多个异步请求,不建议堆叠await,阻塞进程; 同时不建议写多个createAsyncThunk,维护困难
      *   还有第二个参数,action -> {getState,dispatch}
      *   getState可以获取initialState所有的状态,可以获取state使用,但是如果要修改state,必须通过action函数,不可以直接赋值修改!
      */
      export const fetchHomeDataAction = createAsyncThunk('fetchHomeData', async (payload, {dispatch}) => {
        getHomeGoodPriceData().then(res => {
          dispatch(changeGoodPriceInfoAction(res)) // 通过action修改state的值
        })
        getHomeHighscoreData().then(res => {
          dispatch(changeHighScoreInfoAction(res)) 
        })
      })

      const homeSlice = createSlice({
        name: 'home',
        initialState: {
          goodPriceInfo: {},
          highScoreInfo: {}
        },
        reducers: {
          changeGoodPriceInfoAction(state,{payload}){
            state.goodPriceInfo = payload
          },
          changeHighScoreInfoAction(state,{payload}){
            state.highScoreInfo = payload
          }
        }
      })
      // 记得导出action函数
      export const {
        changeGoodPriceInfoAction,
        changeHighScoreInfoAction
      } = homeSlice.actions
      export default homeSlice.reducer
    ```
    > 不再通过extraReducers处理异步数据赋值state,而是转用reducers
  - 3.home派发新的事件fetchHomeDataAction,同时获取store
    ```js
      /** 从redux中获取数据 */
      const { goodPriceInfo,highScoreInfo } = useSelector((state) => ({
        goodPriceInfo: state.home.goodPriceInfo,
        highScoreInfo: state.home.highScoreInfo
      }), shallowEqual)

      /** 派发事件: 发送网络请求,不传参数 */
      const dispatch = useDispatch()
      useEffect(() => {
        dispatch(fetchHomeDataAction())
      }, [])
    ```
    ```html
      <div className='content'>
        <div className='good-price'>
          <SectionHeader title={goodPriceInfo.title} />
          <SectionRooms roomList={goodPriceInfo.list} />
        </div>
        <div className='high-score'>
          <SectionHeader title={highScoreInfo.title} subtitle={highScoreInfo.subtitle} />
          <SectionRooms roomList={highScoreInfo.list}/>
        </div>
      </div>
    ```
### HomeSectionV1
- 针对上面的高分/高性价比房源两个板块,封装进home部分组件home-section-v1
- ==接受房源数据==,然后内部渲染即可,css配置等略
  ```js
    import SectionHeader from '@/components/section-header'
    import SectionRooms from '@/components/section-rooms'

    const HomeSectionV1 = memo((props) => {
      const {infoData} = props
      return (
        <SectionV1Wrapper>
          <SectionHeader title={infoData.title} subtitle={infoData.subtitle}/>
          <SectionRooms roomList={infoData.list}/>
        </SectionV1Wrapper>
      )
    })

    HomeSectionV1.propTypes = {
      infoData: PropTypes.object
    }
  ```
- 主页面home,只需简单传参即可
  ```html
    <div className='content'>
      <HomeSectionV1 infoData={goodPriceInfo}/>
      <HomeSectionV1 infoData={highScoreInfo}/>
    </div>
  ```






